{"version":3,"file":"default-node_modules_ionic_core_dist_esm_form-controller-6cd7ebd1_js-node_modules_ionic_core_-6eb319.js","mappings":"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","sources":["./node_modules/@ionic/core/dist/esm/form-controller-6cd7ebd1.js","./node_modules/@ionic/core/dist/esm/input.utils-4c00ca72.js","./node_modules/@ionic/core/dist/esm/notch-controller-cfcb8c01.js","./node_modules/@ionic/core/dist/esm/theme-7670341c.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { h as findItemLabel } from './helpers-f586db1c.js';\n\n/**\n * Creates a controller that tracks whether a form control is using the legacy or modern syntax. This should be removed when the legacy form control syntax is removed.\n *\n * @internal\n * @prop el: The Ionic form component to reference\n */\nconst createLegacyFormController = (el) => {\n  const controlEl = el;\n  let legacyControl;\n  const hasLegacyControl = () => {\n    if (legacyControl === undefined) {\n      /**\n       * Detect if developers are using the legacy form control syntax\n       * so a deprecation warning is logged. This warning can be disabled\n       * by either using the new `label` property or setting `aria-label`\n       * on the control.\n       * Alternatively, components that use a slot for the label\n       * can check to see if the component has slotted text\n       * in the light DOM.\n       */\n      const hasLabelProp = controlEl.label !== undefined || hasLabelSlot(controlEl);\n      const hasAriaLabelAttribute = controlEl.hasAttribute('aria-label') ||\n        // Shadow DOM form controls cannot use aria-labelledby\n        (controlEl.hasAttribute('aria-labelledby') && controlEl.shadowRoot === null);\n      const legacyItemLabel = findItemLabel(controlEl);\n      /**\n       * Developers can manually opt-out of the modern form markup\n       * by setting `legacy=\"true\"` on components.\n       */\n      legacyControl =\n        controlEl.legacy === true || (!hasLabelProp && !hasAriaLabelAttribute && legacyItemLabel !== null);\n    }\n    return legacyControl;\n  };\n  return { hasLegacyControl };\n};\nconst hasLabelSlot = (controlEl) => {\n  const root = controlEl.shadowRoot;\n  if (root === null) {\n    return false;\n  }\n  /**\n   * Components that have a named label slot\n   * also have other slots, so we need to query for\n   * anything that is explicitly passed to slot=\"label\"\n   */\n  if (NAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.querySelector('[slot=\"label\"]') !== null) {\n    return true;\n  }\n  /**\n   * Components that have an unnamed slot for the label\n   * have no other slots, so we can check the textContent\n   * of the element.\n   */\n  if (UNNAMED_LABEL_SLOT_COMPONENTS.includes(controlEl.tagName) && controlEl.textContent !== '') {\n    return true;\n  }\n  return false;\n};\nconst NAMED_LABEL_SLOT_COMPONENTS = ['ION-RANGE'];\nconst UNNAMED_LABEL_SLOT_COMPONENTS = ['ION-TOGGLE', 'ION-CHECKBOX', 'ION-RADIO'];\n\nexport { createLegacyFormController as c };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-b32cad98.js';\nimport { r as raf } from './helpers-f586db1c.js';\nimport { a as printIonError } from './index-e86f0117.js';\n\n/**\n * Used to update a scoped component that uses emulated slots. This fires when\n * content is passed into the slot or when the content inside of a slot changes.\n * This is not needed for components using native slots in the Shadow DOM.\n * @internal\n * @param el The host element to observe\n * @param slotName mutationCallback will fire when nodes on this slot change\n * @param mutationCallback The callback to fire whenever the slotted content changes\n */\nconst createSlotMutationController = (el, slotName, mutationCallback) => {\n  let hostMutationObserver;\n  let slottedContentMutationObserver;\n  if (win !== undefined && 'MutationObserver' in win) {\n    hostMutationObserver = new MutationObserver((entries) => {\n      for (const entry of entries) {\n        for (const node of entry.addedNodes) {\n          /**\n           * Check to see if the added node\n           *  is our slotted content.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            /**\n             * If so, we want to watch the slotted\n             * content itself for changes. This lets us\n             * detect when content inside of the slot changes.\n             */\n            mutationCallback();\n            /**\n             * Adding the listener in an raf\n             * waits until Stencil moves the slotted element\n             * into the correct place in the event that\n             * slotted content is being added.\n             */\n            raf(() => watchForSlotChange(node));\n            return;\n          }\n        }\n      }\n    });\n    hostMutationObserver.observe(el, {\n      childList: true,\n    });\n  }\n  /**\n   * Listen for changes inside of the slotted content.\n   * We can listen for subtree changes here to be\n   * informed of text within the slotted content\n   * changing. Doing this on the host is possible\n   * but it is much more expensive to do because\n   * it also listens for changes to the internals\n   * of the component.\n   */\n  const watchForSlotChange = (slottedEl) => {\n    var _a;\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n    slottedContentMutationObserver = new MutationObserver((entries) => {\n      mutationCallback();\n      for (const entry of entries) {\n        for (const node of entry.removedNodes) {\n          /**\n           * If the element was removed then we\n           * need to destroy the MutationObserver\n           * so the element can be garbage collected.\n           */\n          if (node.nodeType === Node.ELEMENT_NODE && node.slot === slotName) {\n            destroySlottedContentObserver();\n          }\n        }\n      }\n    });\n    /**\n     * Listen for changes inside of the element\n     * as well as anything deep in the tree.\n     * We listen on the parentElement so that we can\n     * detect when slotted element itself is removed.\n     */\n    slottedContentMutationObserver.observe((_a = slottedEl.parentElement) !== null && _a !== void 0 ? _a : slottedEl, { subtree: true, childList: true });\n  };\n  const destroy = () => {\n    if (hostMutationObserver) {\n      hostMutationObserver.disconnect();\n      hostMutationObserver = undefined;\n    }\n    destroySlottedContentObserver();\n  };\n  const destroySlottedContentObserver = () => {\n    if (slottedContentMutationObserver) {\n      slottedContentMutationObserver.disconnect();\n      slottedContentMutationObserver = undefined;\n    }\n  };\n  return {\n    destroy,\n  };\n};\n\nconst getCounterText = (value, maxLength, counterFormatter) => {\n  const valueLength = value == null ? 0 : value.toString().length;\n  const defaultCounterText = defaultCounterFormatter(valueLength, maxLength);\n  /**\n   * If developers did not pass a custom formatter,\n   * use the default one.\n   */\n  if (counterFormatter === undefined) {\n    return defaultCounterText;\n  }\n  /**\n   * Otherwise, try to use the custom formatter\n   * and fallback to the default formatter if\n   * there was an error.\n   */\n  try {\n    return counterFormatter(valueLength, maxLength);\n  }\n  catch (e) {\n    printIonError('Exception in provided `counterFormatter`.', e);\n    return defaultCounterText;\n  }\n};\nconst defaultCounterFormatter = (length, maxlength) => {\n  return `${length} / ${maxlength}`;\n};\n\nexport { createSlotMutationController as c, getCounterText as g };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { w as win } from './index-b32cad98.js';\nimport { r as raf } from './helpers-f586db1c.js';\n\n/**\n * A utility to calculate the size of an outline notch\n * width relative to the content passed. This is used in\n * components such as `ion-select` with `fill=\"outline\"`\n * where we need to pass slotted HTML content. This is not\n * needed when rendering plaintext content because we can\n * render the plaintext again hidden with `opacity: 0` inside\n * of the notch. As a result we can rely on the intrinsic size\n * of the element to correctly compute the notch width. We\n * cannot do this with slotted content because we cannot project\n * it into 2 places at once.\n *\n * @internal\n * @param el: The host element\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\n * @param getLabelSlot: A function that returns a reference to the slotted content.\n */\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n  let notchVisibilityIO;\n  const needsExplicitNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (\n    /**\n     * If the notch is not being used\n     * then we do not need to set the notch width.\n     */\n    notchSpacerEl === undefined ||\n      /**\n       * If either the label property is being\n       * used or the label slot is not defined,\n       * then we do not need to estimate the notch width.\n       */\n      el.label !== undefined ||\n      getLabelSlot() === null) {\n      return false;\n    }\n    return true;\n  };\n  const calculateNotchWidth = () => {\n    if (needsExplicitNotchWidth()) {\n      /**\n       * Run this the frame after\n       * the browser has re-painted the host element.\n       * Otherwise, the label element may have a width\n       * of 0 and the IntersectionObserver will be used.\n       */\n      raf(() => {\n        setNotchWidth();\n      });\n    }\n  };\n  /**\n   * When using a label prop we can render\n   * the label value inside of the notch and\n   * let the browser calculate the size of the notch.\n   * However, we cannot render the label slot in multiple\n   * places so we need to manually calculate the notch dimension\n   * based on the size of the slotted content.\n   *\n   * This function should only be used to set the notch width\n   * on slotted label content. The notch width for label prop\n   * content is automatically calculated based on the\n   * intrinsic size of the label text.\n   */\n  const setNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (notchSpacerEl === undefined) {\n      return;\n    }\n    if (!needsExplicitNotchWidth()) {\n      notchSpacerEl.style.removeProperty('width');\n      return;\n    }\n    const width = getLabelSlot().scrollWidth;\n    if (\n    /**\n     * If the computed width of the label is 0\n     * and notchSpacerEl's offsetParent is null\n     * then that means the element is hidden.\n     * As a result, we need to wait for the element\n     * to become visible before setting the notch width.\n     *\n     * We do not check el.offsetParent because\n     * that can be null if the host element has\n     * position: fixed applied to it.\n     * notchSpacerEl does not have position: fixed.\n     */\n    width === 0 &&\n      notchSpacerEl.offsetParent === null &&\n      win !== undefined &&\n      'IntersectionObserver' in win) {\n      /**\n       * If there is an IO already attached\n       * then that will update the notch\n       * once the element becomes visible.\n       * As a result, there is no need to create\n       * another one.\n       */\n      if (notchVisibilityIO !== undefined) {\n        return;\n      }\n      const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\n        /**\n         * If the element is visible then we\n         * can try setting the notch width again.\n         */\n        if (ev[0].intersectionRatio === 1) {\n          setNotchWidth();\n          io.disconnect();\n          notchVisibilityIO = undefined;\n        }\n      }, \n      /**\n       * Set the root to be the host element\n       * This causes the IO callback\n       * to be fired in WebKit as soon as the element\n       * is visible. If we used the default root value\n       * then WebKit would only fire the IO callback\n       * after any animations (such as a modal transition)\n       * finished, and there would potentially be a flicker.\n       */\n      { threshold: 0.01, root: el }));\n      io.observe(notchSpacerEl);\n      return;\n    }\n    /**\n     * If the element is visible then we can set the notch width.\n     * The notch is only visible when the label is scaled,\n     * which is why we multiply the width by 0.75 as this is\n     * the same amount the label element is scaled by in the host CSS.\n     * (For ion-select, see $select-floating-label-scale in select.vars.scss).\n     */\n    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n  };\n  const destroy = () => {\n    if (notchVisibilityIO) {\n      notchVisibilityIO.disconnect();\n      notchVisibilityIO = undefined;\n    }\n  };\n  return {\n    calculateNotchWidth,\n    destroy,\n  };\n};\n\nexport { createNotchController as c };\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst hostContext = (selector, el) => {\n  return el.closest(selector) !== null;\n};\n/**\n * Create the mode and color classes for the component based on the classes passed in\n */\nconst createColorClasses = (color, cssClassMap) => {\n  return typeof color === 'string' && color.length > 0\n    ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;\n};\nconst getClassList = (classes) => {\n  if (classes !== undefined) {\n    const array = Array.isArray(classes) ? classes : classes.split(' ');\n    return array\n      .filter((c) => c != null)\n      .map((c) => c.trim())\n      .filter((c) => c !== '');\n  }\n  return [];\n};\nconst getClassMap = (classes) => {\n  const map = {};\n  getClassList(classes).forEach((c) => (map[c] = true));\n  return map;\n};\nconst SCHEME = /^[a-z][a-z0-9+\\-.]*:/;\nconst openURL = async (url, ev, direction, animation) => {\n  if (url != null && url[0] !== '#' && !SCHEME.test(url)) {\n    const router = document.querySelector('ion-router');\n    if (router) {\n      if (ev != null) {\n        ev.preventDefault();\n      }\n      return router.push(url, direction, animation);\n    }\n  }\n  return false;\n};\n\nexport { createColorClasses as c, getClassMap as g, hostContext as h, openURL as o };\n"],"names":["h","findItemLabel","createLegacyFormController","el","controlEl","legacyControl","hasLegacyControl","undefined","hasLabelProp","label","hasLabelSlot","hasAriaLabelAttribute","hasAttribute","shadowRoot","legacyItemLabel","legacy","root","NAMED_LABEL_SLOT_COMPONENTS","includes","tagName","querySelector","UNNAMED_LABEL_SLOT_COMPONENTS","textContent","c","w","win","r","raf","a","printIonError","createSlotMutationController","slotName","mutationCallback","hostMutationObserver","slottedContentMutationObserver","MutationObserver","entries","entry","node","addedNodes","nodeType","Node","ELEMENT_NODE","slot","watchForSlotChange","observe","childList","slottedEl","_a","disconnect","removedNodes","destroySlottedContentObserver","parentElement","subtree","destroy","getCounterText","value","maxLength","counterFormatter","valueLength","toString","length","defaultCounterText","defaultCounterFormatter","e","maxlength","g","createNotchController","getNotchSpacerEl","getLabelSlot","notchVisibilityIO","needsExplicitNotchWidth","notchSpacerEl","calculateNotchWidth","setNotchWidth","style","removeProperty","width","scrollWidth","offsetParent","io","IntersectionObserver","ev","intersectionRatio","threshold","setProperty","hostContext","selector","closest","createColorClasses","color","cssClassMap","Object","assign","getClassList","classes","array","Array","isArray","split","filter","map","trim","getClassMap","forEach","SCHEME","openURL","_ref","_asyncToGenerator","url","direction","animation","test","router","document","preventDefault","push","_x","_x2","_x3","_x4","apply","arguments","o"],"sourceRoot":"webpack:///","x_google_ignoreList":[0,1,2,3]}